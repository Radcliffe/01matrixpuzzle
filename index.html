<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>0-1 matrix puzzle</title>
    <style>
      body {
        margin-left: 20%;
        margin-right: 20%;
        margin-top: 2rem;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }

      .game-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
        max-width: 900px;
        margin: 3rem auto;
        border-bottom: 1px solid #ccc;
        padding-bottom: 1.5rem;

      }

      h1, h2 {
        grid-column: 1 / -1;
        border-bottom: 1px solid #ccc;
        padding-bottom: 0.5rem;
      }

      .controls {
        display: flex;
        gap: 1rem;
        align-items: center;
        margin-bottom: 1rem;
        grid-column: 1 / -1;
      }

      .controls label {
        font-weight: bold;
      }

      .controls input[type="number"] {
        width: 50px;
        padding: 5px;
      }

      .controls button {
        padding: 5px 15px;
        border: 1px solid #ccc;
        background-color: #f0f0f0;
        cursor: pointer;
      }

      .controls button:hover {
        background-color: #e0e0e0;
      }

      .matrix-container {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 10px;
        align-items: center;
      }

      .row-headers {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .row-header {
        padding: 10px;
        font-weight: bold;
        cursor: pointer;
        border: 1px solid #ccc;
        background-color: #f0f0f0;
        text-align: center;
        user-select: none;
      }

      .row-header.selected-from {
        background-color: #64b5f6; /* Blue for source row */
        color: white;
      }

      .matrix {
        display: grid;
        border: 2px solid #333;
        background-color: #ccc;
        gap: 2px;
      }

      .matrix-cell {
        width: 40px;
        height: 40px;
        background-color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.2rem;
        font-weight: bold;
        cursor: pointer;
        user-select: none;
      }

      .history-container {
        padding: 1rem;
        border: 1px solid #ddd;
        background-color: #fafafa;
      }

      .history-container h3 {
        margin-top: 0;
      }

      #history-list {
        padding-left: 1.5rem;
        margin: 0;
      }

      @media (max-width: 600px) {
        body {
          grid-template-columns: 1fr;
        }
      }
    </style>
</head>
<body>

<h1>0-1 Matrix Puzzle</h1>

<p><strong>Instructions:</strong>
    Transform the matrix to the identity matrix in <span id="goal">9</span> steps.
    The identity matrix has ones along the main diagonal (top left to bottom right)
    and zeros elsewhere. A step consists of adding one row to another, then replacing
    the twos with zeros (i.e. adding mod 2).
    To perform this operation, click on two of the buttons
    <span id="row-names">(R1, R2, R3, R4)</span> to the left of the matrix.</p>

<p>It is believed (but not proved?) that 3n &minus; 3 steps are required in general.
    Can you prove this? Let me know!</p>

<div class="game-container">
    <div class="controls">
        <label for="n-selector">Dimension (n):</label>
        <input type="number" id="n-selector" value="4" min="2" max="8">
        <button id="undo-button">Undo Last Operation</button>
        <button id="reset-button">Reset</button>
    </div>

    <div class="matrix-container">
        <div id="row-headers" class="row-headers"></div>
        <div id="matrix" class="matrix"></div>
    </div>

    <div class="history-container">
        <h3>History</h3>
        <ol id="history-list"></ol>
    </div>
</div>

<p><strong>Technical discussion:</strong>
    This app explores the group of nonsingular n-by-n matrices over the field of two elements.
    This group is generated by transvections, i.e. adding one row to another row mod 2.</p>

<p>A row swap can be decomposed into three transvections, by the
    <a href="https://en.wikipedia.org/wiki/XOR_swap_algorithm">XOR trick</a>.
    Since any permutation of n elements can be expressed as the product of at most n &minus; 1 transpositions,
    it follows that any permutation matrix can be expressed as the product of at most 3n &minus; 3 transvections.</p>

<p>It is <a href="https://arxiv.org/abs/2503.01467">conjectured</a> that the permutation matrix corresponding to an
    n-cycle requires no fewer than 3n &minus; 3 transvections. This has been verified up to n = 8.</p>

<script>
    // === STATE ===
    let n = 4;
    let matrix = [];
    let history = []; // [{ from: r1, to: r2 }, ...]
    let selectedRows = []; // [fromRow, toRow]

    // === DOM ELEMENTS ===
    const nSelector = document.getElementById('n-selector');
    const undoButton = document.getElementById('undo-button');
    const resetButton = document.getElementById('reset-button');
    const matrixGrid = document.getElementById('matrix');
    const rowHeadersContainer = document.getElementById('row-headers');
    const historyList = document.getElementById('history-list');
    const goalElement = document.getElementById('goal');

    // === LOGIC ===

    /** Initializes the application state and renders the UI */
    function initialize() {
        n = parseInt(nSelector.value, 10);
        matrix = Array(n).fill(0).map(() => Array(n).fill(0));
        history = [];
        selectedRows = [];
        for (let i = 0; i < n; i++) {
            matrix[i][(i + 1) % n] = 1;
        }
        render();
    }

    /** Renders the entire UI based on the current state */
    function render() {
        // Render Matrix Grid
        matrixGrid.innerHTML = '';
        matrixGrid.style.gridTemplateColumns = `repeat(${n}, 1fr)`;
        matrix.forEach((row, i) => {
            row.forEach((val, j) => {
                const cell = document.createElement('div');
                cell.className = 'matrix-cell';
                cell.textContent = val;
                cell.dataset.i = i;
                cell.dataset.j = j;
                if (val === 1) {
                    cell.style.backgroundColor = '#64b5f6'; // Blue for 1
                } else {
                    cell.style.backgroundColor = 'white'; // White for 0
                }
                matrixGrid.appendChild(cell);
            });
        });

        // Render Row Headers
        rowHeadersContainer.innerHTML = '';
        for (let i = 0; i < n; i++) {
            const header = document.createElement('div');
            header.className = 'row-header';
            header.textContent = `R${i + 1}`;
            header.dataset.i = i;
            if (selectedRows.length === 1 && selectedRows[0] === i) {
                header.classList.add('selected-from');
            }
            rowHeadersContainer.appendChild(header);
        }

        // Render History List
        historyList.innerHTML = '';
        history.forEach(op => {
            const listItem = document.createElement('li');
            listItem.innerHTML = `R${op.to + 1} ← R${op.to + 1} + R${op.from + 1}`;
            historyList.appendChild(listItem);
        });

        // Update the goal element
        goalElement.textContent = (3 * n - 3).toString();

        // Render row names
        const rowNames = Array.from({length: n}, (_, i) => `R${i + 1}`).join(', ');
        document.getElementById('row-names').textContent = `(${rowNames})`;
    }

    // Check if matrix is the identity.
    function checkIfIdentity() {
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i === j && matrix[i][j] !== 1) return false;
                if (i !== j && matrix[i][j] !== 0) return false;
            }
        }
        return true;
    }

    // === EVENT HANDLERS ===

    /** Handles changing the matrix dimension n */
    function handleNChange() {
        const newN = parseInt(nSelector.value, 10);
        if (newN >= 2 && newN <= 8) {
            initialize();
        } else {
            nSelector.value = n; // Revert if invalid
        }
    }

    /** Handles selecting a row for an operation */
    function handleRowSelect(event) {
        if (!event.target.classList.contains('row-header')) return;
        const rowIndex = parseInt(event.target.dataset.i, 10);

        if (selectedRows.length === 0) {
            // First row selected (source)
            selectedRows.push(rowIndex);
        } else if (selectedRows.length === 1) {
            // Second row selected (destination)
            if (rowIndex === selectedRows[0]) {
                // Deselect if the same row is clicked again
                selectedRows = [];
            } else {
                selectedRows.push(rowIndex);
                performRowOperation();
            }
        }
        render();
    }

    /** Performs the row operation and updates history */
    function performRowOperation() {
        const [fromRow, toRow] = selectedRows;

        // Add fromRow to toRow (mod 2)
        for (let j = 0; j < n; j++) {
            matrix[toRow][j] = (matrix[toRow][j] + matrix[fromRow][j]) % 2;
        }

        history.push({from: fromRow, to: toRow});
        selectedRows = []; // Reset selection after operation

        // Check if the matrix is now the identity matrix.
        // Congratulate the user if they achieved it in 3*n moves or less.
        if (checkIfIdentity()) {
            alert(`Congratulations! You transformed the matrix to the identity in ${history.length} moves.`);
        }
    }

    /** Undoes the last row operation */
    function handleUndo() {
        if (history.length === 0) return;

        const lastOp = history.pop();
        const {from, to} = lastOp;

        // In F_2, adding a row to another is its own inverse.
        // So, to undo, we just do the same operation again.
        for (let j = 0; j < n; j++) {
            matrix[to][j] = (matrix[to][j] + matrix[from][j]) % 2;
        }
        render();
    }


    // === INITIALIZATION ===
    nSelector.addEventListener('change', handleNChange);
    undoButton.addEventListener('click', handleUndo);
    resetButton.addEventListener('click', initialize);
    rowHeadersContainer.addEventListener('click', handleRowSelect);

    // Load MathJax for LaTeX rendering
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
    script.async = true;
    document.head.appendChild(script);

    // Initial call
    initialize();

</script>
</body>
</html>
